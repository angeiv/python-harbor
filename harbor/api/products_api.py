# coding: utf-8

"""
    Harbor API

    These APIs provide services for manipulating Harbor project.  # noqa: E501

    OpenAPI spec version: 1.10.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from harbor.api_client import ApiClient


class ProductsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def chartrepo_charts_post(self, chart, prov, **kwargs):  # noqa: E501
        """Upload a chart file to the defult 'library' project.  # noqa: E501

        Upload a chart file to the default 'library' project. Uploading together with the prov file at the same time is also supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_charts_post(chart, prov, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str chart: (required)
        :param str prov: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_charts_post_with_http_info(chart, prov, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_charts_post_with_http_info(chart, prov, **kwargs)  # noqa: E501
            return data

    def chartrepo_charts_post_with_http_info(self, chart, prov, **kwargs):  # noqa: E501
        """Upload a chart file to the defult 'library' project.  # noqa: E501

        Upload a chart file to the default 'library' project. Uploading together with the prov file at the same time is also supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_charts_post_with_http_info(chart, prov, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str chart: (required)
        :param str prov: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart', 'prov']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_charts_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chart' is set
        if ('chart' not in params or
                params['chart'] is None):
            raise ValueError("Missing the required parameter `chart` when calling `chartrepo_charts_post`")  # noqa: E501
        # verify the required parameter 'prov' is set
        if ('prov' not in params or
                params['prov'] is None):
            raise ValueError("Missing the required parameter `prov` when calling `chartrepo_charts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'chart' in params:
            local_var_files['chart'] = params['chart']  # noqa: E501
        if 'prov' in params:
            local_var_files['prov'] = params['prov']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/charts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_health_get(self, **kwargs):  # noqa: E501
        """Check the health of chart repository service.  # noqa: E501

        Check the health of chart repository service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_health_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_health_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_health_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def chartrepo_health_get_with_http_info(self, **kwargs):  # noqa: E501
        """Check the health of chart repository service.  # noqa: E501

        Check the health of chart repository service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_health_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_health_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/health', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_get(self, repo, **kwargs):  # noqa: E501
        """Get all the charts under the specified project  # noqa: E501

        Get all the charts under the specified project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_get(repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :return: list[ChartInfoEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_get_with_http_info(repo, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_get_with_http_info(repo, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_get_with_http_info(self, repo, **kwargs):  # noqa: E501
        """Get all the charts under the specified project  # noqa: E501

        Get all the charts under the specified project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_get_with_http_info(repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :return: list[ChartInfoEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ChartInfoEntry]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_delete(self, repo, name, **kwargs):  # noqa: E501
        """Delete all the versions of the specified chart  # noqa: E501

        Delete all the versions of the specified chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_delete(repo, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_delete_with_http_info(repo, name, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_delete_with_http_info(repo, name, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_delete_with_http_info(self, repo, name, **kwargs):  # noqa: E501
        """Delete all the versions of the specified chart  # noqa: E501

        Delete all the versions of the specified chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_delete_with_http_info(repo, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_delete`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_get(self, repo, name, **kwargs):  # noqa: E501
        """Get all the versions of the specified chart  # noqa: E501

        Get all the versions of the specified chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_get(repo, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :return: ChartVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_get_with_http_info(repo, name, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_get_with_http_info(repo, name, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_get_with_http_info(self, repo, name, **kwargs):  # noqa: E501
        """Get all the versions of the specified chart  # noqa: E501

        Get all the versions of the specified chart  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_get_with_http_info(repo, name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :return: ChartVersions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_get`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChartVersions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_version_delete(self, repo, name, version, **kwargs):  # noqa: E501
        """Delete the specified chart version  # noqa: E501

        Delete the specified chart version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_delete(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_version_delete_with_http_info(repo, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_version_delete_with_http_info(repo, name, version, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_version_delete_with_http_info(self, repo, name, version, **kwargs):  # noqa: E501
        """Delete the specified chart version  # noqa: E501

        Delete the specified chart version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_delete_with_http_info(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_version_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_version_delete`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_version_delete`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `chartrepo_repo_charts_name_version_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}/{version}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_version_get(self, repo, name, version, **kwargs):  # noqa: E501
        """Get the specified chart version  # noqa: E501

        Get the specified chart version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_get(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: ChartVersionDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_version_get_with_http_info(repo, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_version_get_with_http_info(repo, name, version, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_version_get_with_http_info(self, repo, name, version, **kwargs):  # noqa: E501
        """Get the specified chart version  # noqa: E501

        Get the specified chart version  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_get_with_http_info(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: ChartVersionDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_version_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_version_get`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_version_get`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `chartrepo_repo_charts_name_version_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}/{version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ChartVersionDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_version_labels_get(self, repo, name, version, **kwargs):  # noqa: E501
        """Return the attahced labels of chart.  # noqa: E501

        Return the attahced labels of the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_get(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_version_labels_get_with_http_info(repo, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_version_labels_get_with_http_info(repo, name, version, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_version_labels_get_with_http_info(self, repo, name, version, **kwargs):  # noqa: E501
        """Return the attahced labels of chart.  # noqa: E501

        Return the attahced labels of the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_get_with_http_info(repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_version_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_version_labels_get`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_version_labels_get`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `chartrepo_repo_charts_name_version_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}/{version}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_version_labels_id_delete(self, repo, name, version, id, **kwargs):  # noqa: E501
        """Remove label from chart.  # noqa: E501

        Remove label from the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_id_delete(repo, name, version, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :param int id: The label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_version_labels_id_delete_with_http_info(repo, name, version, id, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_version_labels_id_delete_with_http_info(repo, name, version, id, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_version_labels_id_delete_with_http_info(self, repo, name, version, id, **kwargs):  # noqa: E501
        """Remove label from chart.  # noqa: E501

        Remove label from the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_id_delete_with_http_info(repo, name, version, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :param int id: The label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo', 'name', 'version', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_version_labels_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_version_labels_id_delete`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_version_labels_id_delete`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `chartrepo_repo_charts_name_version_labels_id_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `chartrepo_repo_charts_name_version_labels_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}/{version}/labels/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_name_version_labels_post(self, body, repo, name, version, **kwargs):  # noqa: E501
        """Mark label to chart.  # noqa: E501

        Mark label to the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_post(body, repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The label being marked to the chart version (required)
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_name_version_labels_post_with_http_info(body, repo, name, version, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_name_version_labels_post_with_http_info(body, repo, name, version, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_name_version_labels_post_with_http_info(self, body, repo, name, version, **kwargs):  # noqa: E501
        """Mark label to chart.  # noqa: E501

        Mark label to the specified chart version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_name_version_labels_post_with_http_info(body, repo, name, version, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The label being marked to the chart version (required)
        :param str repo: The project name (required)
        :param str name: The chart name (required)
        :param str version: The chart version (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repo', 'name', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_name_version_labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `chartrepo_repo_charts_name_version_labels_post`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_name_version_labels_post`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `chartrepo_repo_charts_name_version_labels_post`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `chartrepo_repo_charts_name_version_labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts/{name}/{version}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_charts_post(self, chart, prov, repo, **kwargs):  # noqa: E501
        """Upload a chart file to the specified project.  # noqa: E501

        Upload a chart file to the specified project. With this API, the corresponding provance file can be uploaded together with chart file at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_post(chart, prov, repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str chart: (required)
        :param str prov: (required)
        :param str repo: The project name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_charts_post_with_http_info(chart, prov, repo, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_charts_post_with_http_info(chart, prov, repo, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_charts_post_with_http_info(self, chart, prov, repo, **kwargs):  # noqa: E501
        """Upload a chart file to the specified project.  # noqa: E501

        Upload a chart file to the specified project. With this API, the corresponding provance file can be uploaded together with chart file at once.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_charts_post_with_http_info(chart, prov, repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str chart: (required)
        :param str prov: (required)
        :param str repo: The project name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['chart', 'prov', 'repo']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_charts_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'chart' is set
        if ('chart' not in params or
                params['chart'] is None):
            raise ValueError("Missing the required parameter `chart` when calling `chartrepo_repo_charts_post`")  # noqa: E501
        # verify the required parameter 'prov' is set
        if ('prov' not in params or
                params['prov'] is None):
            raise ValueError("Missing the required parameter `prov` when calling `chartrepo_repo_charts_post`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_charts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'chart' in params:
            local_var_files['chart'] = params['chart']  # noqa: E501
        if 'prov' in params:
            local_var_files['prov'] = params['prov']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/charts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def chartrepo_repo_prov_post(self, prov, repo, **kwargs):  # noqa: E501
        """Upload a provance file to the specified project.  # noqa: E501

        Upload a provance file to the specified project. The provance file should be targeted for an existing chart file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_prov_post(prov, repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str prov: (required)
        :param str repo: The project name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.chartrepo_repo_prov_post_with_http_info(prov, repo, **kwargs)  # noqa: E501
        else:
            (data) = self.chartrepo_repo_prov_post_with_http_info(prov, repo, **kwargs)  # noqa: E501
            return data

    def chartrepo_repo_prov_post_with_http_info(self, prov, repo, **kwargs):  # noqa: E501
        """Upload a provance file to the specified project.  # noqa: E501

        Upload a provance file to the specified project. The provance file should be targeted for an existing chart file.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.chartrepo_repo_prov_post_with_http_info(prov, repo, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str prov: (required)
        :param str repo: The project name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['prov', 'repo']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method chartrepo_repo_prov_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'prov' is set
        if ('prov' not in params or
                params['prov'] is None):
            raise ValueError("Missing the required parameter `prov` when calling `chartrepo_repo_prov_post`")  # noqa: E501
        # verify the required parameter 'repo' is set
        if ('repo' not in params or
                params['repo'] is None):
            raise ValueError("Missing the required parameter `repo` when calling `chartrepo_repo_prov_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo' in params:
            path_params['repo'] = params['repo']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'prov' in params:
            local_var_files['prov'] = params['prov']  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/chartrepo/{repo}/prov', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configurations_get(self, **kwargs):  # noqa: E501
        """Get system configurations.  # noqa: E501

        This endpoint is for retrieving system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configurations_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ConfigurationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.configurations_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.configurations_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def configurations_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get system configurations.  # noqa: E501

        This endpoint is for retrieving system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configurations_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: ConfigurationsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configurations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConfigurationsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def configurations_put(self, body, **kwargs):  # noqa: E501
        """Modify system configurations.  # noqa: E501

        This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configurations_put(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Configurations body: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.configurations_put_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.configurations_put_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def configurations_put_with_http_info(self, body, **kwargs):  # noqa: E501
        """Modify system configurations.  # noqa: E501

        This endpoint is for modifying system configurations that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.configurations_put_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Configurations body: The configuration map can contain a subset of the attributes of the schema, which are to be updated. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method configurations_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `configurations_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/configurations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def email_ping_post(self, **kwargs):  # noqa: E501
        """Test connection and authentication with email server.  # noqa: E501

        Test connection and authentication with email server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_ping_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailServerSetting body: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.email_ping_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.email_ping_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def email_ping_post_with_http_info(self, **kwargs):  # noqa: E501
        """Test connection and authentication with email server.  # noqa: E501

        Test connection and authentication with email server.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.email_ping_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param EmailServerSetting body: Email server settings, if some of the settings are not assigned, they will be read from system configuration.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method email_ping_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/email/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def health_get(self, **kwargs):  # noqa: E501
        """Health check API  # noqa: E501

        The endpoint returns the health stauts of the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OverallHealthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.health_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.health_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def health_get_with_http_info(self, **kwargs):  # noqa: E501
        """Health check API  # noqa: E501

        The endpoint returns the health stauts of the system.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.health_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: OverallHealthStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method health_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/health', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OverallHealthStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def internal_switchquota_put(self, body, **kwargs):  # noqa: E501
        """Enable or disable quota.  # noqa: E501

        This endpoint is for enable/disable quota. When quota is disabled, no resource require/release in image/chart push and delete.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_switchquota_put(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuotaSwitcher body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.internal_switchquota_put_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.internal_switchquota_put_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def internal_switchquota_put_with_http_info(self, body, **kwargs):  # noqa: E501
        """Enable or disable quota.  # noqa: E501

        This endpoint is for enable/disable quota. When quota is disabled, no resource require/release in image/chart push and delete.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_switchquota_put_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuotaSwitcher body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_switchquota_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `internal_switchquota_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/internal/switchquota', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def internal_syncquota_post(self, **kwargs):  # noqa: E501
        """Sync quota from registry/chart to DB.  # noqa: E501

        This endpoint is for syncing quota usage of registry/chart with database.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_syncquota_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.internal_syncquota_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.internal_syncquota_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def internal_syncquota_post_with_http_info(self, **kwargs):  # noqa: E501
        """Sync quota from registry/chart to DB.  # noqa: E501

        This endpoint is for syncing quota usage of registry/chart with database.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_syncquota_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_syncquota_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/internal/syncquota', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def internal_syncregistry_post(self, **kwargs):  # noqa: E501
        """Sync repositories from registry to DB.  # noqa: E501

        This endpoint is for syncing all repositories of registry with database.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_syncregistry_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.internal_syncregistry_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.internal_syncregistry_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def internal_syncregistry_post_with_http_info(self, **kwargs):  # noqa: E501
        """Sync repositories from registry to DB.  # noqa: E501

        This endpoint is for syncing all repositories of registry with database.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.internal_syncregistry_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method internal_syncregistry_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/internal/syncregistry', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_get(self, scope, **kwargs):  # noqa: E501
        """List labels according to the query strings.  # noqa: E501

        This endpoint let user list labels by name, scope and project_id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_get(scope, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels. (required)
        :param str name: The label name.
        :param int project_id: Relevant project ID, required when scope is p.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_get_with_http_info(scope, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_get_with_http_info(scope, **kwargs)  # noqa: E501
            return data

    def labels_get_with_http_info(self, scope, **kwargs):  # noqa: E501
        """List labels according to the query strings.  # noqa: E501

        This endpoint let user list labels by name, scope and project_id   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_get_with_http_info(scope, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: The label scope. Valid values are g and p. g for global labels and p for project labels. (required)
        :param str name: The label name.
        :param int project_id: Relevant project ID, required when scope is p.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['scope', 'name', 'project_id', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'scope' is set
        if ('scope' not in params or
                params['scope'] is None):
            raise ValueError("Missing the required parameter `scope` when calling `labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete the label specified by ID.  # noqa: E501

        Delete the label specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete the label specified by ID.  # noqa: E501

        Delete the label specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_get(self, id, **kwargs):  # noqa: E501
        """Get the label specified by ID.  # noqa: E501

        This endpoint let user get the label by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the label specified by ID.  # noqa: E501

        This endpoint let user get the label by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_put(self, body, id, **kwargs):  # noqa: E501
        """Update the label properties.  # noqa: E501

        This endpoint let user update label properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_put(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The updated label json object. (required)
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def labels_id_put_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update the label properties.  # noqa: E501

        This endpoint let user update label properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_put_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The updated label json object. (required)
        :param int id: Label ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `labels_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_id_resources_get(self, id, **kwargs):  # noqa: E501
        """Get the resources that the label is referenced by.  # noqa: E501

        This endpoint let user get the resources that the label is referenced by. Only the replication policies are returned for now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_resources_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_id_resources_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_id_resources_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def labels_id_resources_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the resources that the label is referenced by.  # noqa: E501

        This endpoint let user get the resources that the label is referenced by. Only the replication policies are returned for now.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_id_resources_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Label ID (required)
        :return: Resource
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_id_resources_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `labels_id_resources_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels/{id}/resources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Resource',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def labels_post(self, body, **kwargs):  # noqa: E501
        """Post creates a label  # noqa: E501

        This endpoint let user creates a label.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The json object of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.labels_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.labels_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def labels_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Post creates a label  # noqa: E501

        This endpoint let user creates a label.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.labels_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: The json object of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_groups_search_get(self, **kwargs):  # noqa: E501
        """Search available ldap groups.  # noqa: E501

        This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_groups_search_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str groupname: Ldap group name
        :param str groupdn: The LDAP group DN
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ldap_groups_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_groups_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_groups_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search available ldap groups.  # noqa: E501

        This endpoint searches the available ldap groups based on related configuration parameters. support to search by groupname or groupdn.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_groups_search_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str groupname: Ldap group name
        :param str groupdn: The LDAP group DN
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['groupname', 'groupdn']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_groups_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'groupname' in params:
            query_params.append(('groupname', params['groupname']))  # noqa: E501
        if 'groupdn' in params:
            query_params.append(('groupdn', params['groupdn']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/groups/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_ping_post(self, **kwargs):  # noqa: E501
        """Ping available ldap service.  # noqa: E501

        This endpoint ping the available ldap service for test related configuration parameters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_ping_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LdapConf body: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ldap_ping_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_ping_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_ping_post_with_http_info(self, **kwargs):  # noqa: E501
        """Ping available ldap service.  # noqa: E501

        This endpoint ping the available ldap service for test related configuration parameters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_ping_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LdapConf body: ldap configuration. support input ldap service configuration. If it's a empty request, will load current configuration from the system.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_ping_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_users_import_post(self, body, **kwargs):  # noqa: E501
        """Import selected available ldap users.  # noqa: E501

        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information. If have errors when import user, will return the list of importing failed uid and the failed reason.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_users_import_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LdapImportUsers body: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ldap_users_import_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.ldap_users_import_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def ldap_users_import_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Import selected available ldap users.  # noqa: E501

        This endpoint adds the selected available ldap users to harbor based on related configuration parameters from the system. System will try to guess the user email address and realname, add to harbor user information. If have errors when import user, will return the list of importing failed uid and the failed reason.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_users_import_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LdapImportUsers body: The uid listed for importing. This list will check users validity of ldap service based on configuration from the system. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_import_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `ldap_users_import_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/users/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def ldap_users_search_get(self, **kwargs):  # noqa: E501
        """Search available ldap users.  # noqa: E501

        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_users_search_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Registered user ID
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.ldap_users_search_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ldap_users_search_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ldap_users_search_get_with_http_info(self, **kwargs):  # noqa: E501
        """Search available ldap users.  # noqa: E501

        This endpoint searches the available ldap users based on related configuration parameters. Support searched by input ladp configuration, load configuration from the system and specific filter.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ldap_users_search_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Registered user ID
        :return: list[LdapUsers]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ldap_users_search_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/ldap/users/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[LdapUsers]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logs_get(self, **kwargs):  # noqa: E501
        """Get recent logs of the projects which the user is a member of  # noqa: E501

        This endpoint let user see the recent operation logs of the projects which he is member of   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.logs_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.logs_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def logs_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get recent logs of the projects which the user is a member of  # noqa: E501

        This endpoint let user see the recent operation logs of the projects which he is member of   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logs_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logs_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'repository' in params:
            query_params.append(('repository', params['repository']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))  # noqa: E501
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccessLog]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_get(self, **kwargs):  # noqa: E501
        """List projects  # noqa: E501

        This endpoint returns all projects created by Harbor, and can be filtered by project name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.projects_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def projects_get_with_http_info(self, **kwargs):  # noqa: E501
        """List projects  # noqa: E501

        This endpoint returns all projects created by Harbor, and can be filtered by project name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The name of project.
        :param bool public: The project is public or private.
        :param str owner: The name of project owner.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Project]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'public', 'owner', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'public' in params:
            query_params.append(('public', params['public']))  # noqa: E501
        if 'owner' in params:
            query_params.append(('owner', params['owner']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Project]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_head(self, project_name, **kwargs):  # noqa: E501
        """Check if the project name user provided already exists.  # noqa: E501

        This endpoint is used to check if the project name user provided already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_head(project_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_head_with_http_info(project_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_head_with_http_info(project_name, **kwargs)  # noqa: E501
            return data

    def projects_head_with_http_info(self, project_name, **kwargs):  # noqa: E501
        """Check if the project name user provided already exists.  # noqa: E501

        This endpoint is used to check if the project name user provided already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_head_with_http_info(project_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: Project name for checking exists. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_head" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params or
                params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `projects_head`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_name' in params:
            query_params.append(('project_name', params['project_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_post(self, body, **kwargs):  # noqa: E501
        """Create a new project.  # noqa: E501

        This endpoint is for user to create a new project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectReq body: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def projects_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new project.  # noqa: E501

        This endpoint is for user to create a new project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectReq body: New created project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_delete(self, project_id, **kwargs):  # noqa: E501
        """Delete project by projectID  # noqa: E501

        This endpoint is aimed to delete project by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_delete(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_delete_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_delete_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Delete project by projectID  # noqa: E501

        This endpoint is aimed to delete project by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_delete_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID of project which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_get(self, project_id, **kwargs):  # noqa: E501
        """Return specific project detail information  # noqa: E501

        This endpoint returns specific project information by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Return specific project detail information  # noqa: E501

        This endpoint returns specific project information by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID for filtering results. (required)
        :return: Project
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Project',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_immutabletagrules_get(self, project_id, **kwargs):  # noqa: E501
        """List all immutable tag rules of current project  # noqa: E501

        This endpoint returns the immutable tag rules of a project   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[ImmutableTagRule]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_immutabletagrules_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_immutabletagrules_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_immutabletagrules_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List all immutable tag rules of current project  # noqa: E501

        This endpoint returns the immutable tag rules of a project   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[ImmutableTagRule]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_immutabletagrules_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_immutabletagrules_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/immutabletagrules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ImmutableTagRule]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_immutabletagrules_id_delete(self, project_id, id, **kwargs):  # noqa: E501
        """Delete the immutable tag rule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_id_delete(project_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int id: Immutable tag rule ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_immutabletagrules_id_delete_with_http_info(project_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_immutabletagrules_id_delete_with_http_info(project_id, id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_immutabletagrules_id_delete_with_http_info(self, project_id, id, **kwargs):  # noqa: E501
        """Delete the immutable tag rule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_id_delete_with_http_info(project_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int id: Immutable tag rule ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_immutabletagrules_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_immutabletagrules_id_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_immutabletagrules_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/immutabletagrules/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_immutabletagrules_id_put(self, project_id, id, **kwargs):  # noqa: E501
        """Update the immutable tag rule or enable or disable the rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_id_put(project_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int id: Immutable tag rule ID. (required)
        :param ImmutableTagRule body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_immutabletagrules_id_put_with_http_info(project_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_immutabletagrules_id_put_with_http_info(project_id, id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_immutabletagrules_id_put_with_http_info(self, project_id, id, **kwargs):  # noqa: E501
        """Update the immutable tag rule or enable or disable the rule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_id_put_with_http_info(project_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int id: Immutable tag rule ID. (required)
        :param ImmutableTagRule body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_immutabletagrules_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_immutabletagrules_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `projects_project_id_immutabletagrules_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/immutabletagrules/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_immutabletagrules_post(self, project_id, **kwargs):  # noqa: E501
        """Add an immutable tag rule to current project  # noqa: E501

        This endpoint add an immutable tag rule to the project   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_post(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param ImmutableTagRule body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_immutabletagrules_post_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_immutabletagrules_post_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_immutabletagrules_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Add an immutable tag rule to current project  # noqa: E501

        This endpoint add an immutable tag rule to the project   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_immutabletagrules_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param ImmutableTagRule body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_immutabletagrules_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_immutabletagrules_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/immutabletagrules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_logs_get(self, project_id, **kwargs):  # noqa: E501
        """Get access logs accompany with a relevant project.  # noqa: E501

        This endpoint let user search access logs filtered by operations and date time ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_logs_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_logs_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_logs_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get access logs accompany with a relevant project.  # noqa: E501

        This endpoint let user search access logs filtered by operations and date time ranges.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_logs_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID (required)
        :param str username: Username of the operator.
        :param str repository: The name of repository
        :param str tag: The name of tag
        :param str operation: The operation
        :param str begin_timestamp: The begin timestamp
        :param str end_timestamp: The end timestamp
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[AccessLog]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'username', 'repository', 'tag', 'operation', 'begin_timestamp', 'end_timestamp', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_logs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'repository' in params:
            query_params.append(('repository', params['repository']))  # noqa: E501
        if 'tag' in params:
            query_params.append(('tag', params['tag']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'begin_timestamp' in params:
            query_params.append(('begin_timestamp', params['begin_timestamp']))  # noqa: E501
        if 'end_timestamp' in params:
            query_params.append(('end_timestamp', params['end_timestamp']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccessLog]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_get(self, project_id, **kwargs):  # noqa: E501
        """Get all project member information  # noqa: E501

        Get all project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param str entityname: The entity name to search.
        :return: list[ProjectMemberEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_members_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get all project member information  # noqa: E501

        Get all project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param str entityname: The entity name to search.
        :return: list[ProjectMemberEntity]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'entityname']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'entityname' in params:
            query_params.append(('entityname', params['entityname']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ProjectMemberEntity]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_delete(self, project_id, mid, **kwargs):  # noqa: E501
        """Delete project member  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_delete(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_members_mid_delete_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_delete_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_delete_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Delete project member  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_delete_with_http_info(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_delete`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_get(self, project_id, mid, **kwargs):  # noqa: E501
        """Get the project member information  # noqa: E501

        Get the project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_get(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: The member ID (required)
        :return: ProjectMemberEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_members_mid_get_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_get_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_get_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Get the project member information  # noqa: E501

        Get the project member information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_get_with_http_info(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: The member ID (required)
        :return: ProjectMemberEntity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_get`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMemberEntity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_mid_put(self, project_id, mid, **kwargs):  # noqa: E501
        """Update project member  # noqa: E501

        Update project member relationship  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_put(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :param RoleRequest body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_members_mid_put_with_http_info(project_id, mid, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_mid_put_with_http_info(project_id, mid, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_mid_put_with_http_info(self, project_id, mid, **kwargs):  # noqa: E501
        """Update project member  # noqa: E501

        Update project member relationship  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_mid_put_with_http_info(project_id, mid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int mid: Member ID. (required)
        :param RoleRequest body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'mid', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_mid_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_mid_put`")  # noqa: E501
        # verify the required parameter 'mid' is set
        if ('mid' not in params or
                params['mid'] is None):
            raise ValueError("Missing the required parameter `mid` when calling `projects_project_id_members_mid_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'mid' in params:
            path_params['mid'] = params['mid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members/{mid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_members_post(self, project_id, **kwargs):  # noqa: E501
        """Create project member  # noqa: E501

        Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_post(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param ProjectMember body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_members_post_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_members_post_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_members_post_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create project member  # noqa: E501

        Create project member relationship, the member can be one of the user_member and group_member,  The user_member need to specify user_id or username. If the user already exist in harbor DB, specify the user_id,  If does not exist in harbor DB, it will SearchAndOnBoard the user. The group_member need to specify id or ldap_group_dn. If the group already exist in harbor DB. specify the user group's id,  If does not exist, it will SearchAndOnBoard the group.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_members_post_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param ProjectMember body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_members_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_members_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/members', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_get(self, project_id, **kwargs):  # noqa: E501
        """Get project metadata.  # noqa: E501

        This endpoint returns metadata of the project specified by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_metadatas_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get project metadata.  # noqa: E501

        This endpoint returns metadata of the project specified by project ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_delete(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Delete metadata of a project  # noqa: E501

        This endpoint is aimed to delete metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_delete(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_delete_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Delete metadata of a project  # noqa: E501

        This endpoint is aimed to delete metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_delete_with_http_info(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_delete`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_get(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Get project metadata  # noqa: E501

        This endpoint returns specified metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_get(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID for filtering results. (required)
        :param str meta_name: The name of metadat. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_get_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Get project metadata  # noqa: E501

        This endpoint returns specified metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_get_with_http_info(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Project ID for filtering results. (required)
        :param str meta_name: The name of metadat. (required)
        :return: ProjectMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_get`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_meta_name_put(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Update metadata of a project.  # noqa: E501

        This endpoint is aimed to update the metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_put(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_meta_name_put_with_http_info(self, project_id, meta_name, **kwargs):  # noqa: E501
        """Update metadata of a project.  # noqa: E501

        This endpoint is aimed to update the metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_meta_name_put_with_http_info(project_id, meta_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The ID of project. (required)
        :param str meta_name: The name of metadat. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'meta_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_meta_name_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_meta_name_put`")  # noqa: E501
        # verify the required parameter 'meta_name' is set
        if ('meta_name' not in params or
                params['meta_name'] is None):
            raise ValueError("Missing the required parameter `meta_name` when calling `projects_project_id_metadatas_meta_name_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'meta_name' in params:
            path_params['meta_name'] = params['meta_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas/{meta_name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_metadatas_post(self, body, project_id, **kwargs):  # noqa: E501
        """Add metadata for the project.  # noqa: E501

        This endpoint is aimed to add metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_post(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectMetadata body: The metadata of project. (required)
        :param int project_id: Selected project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_metadatas_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_metadatas_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_metadatas_post_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Add metadata for the project.  # noqa: E501

        This endpoint is aimed to add metadata of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_metadatas_post_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectMetadata body: The metadata of project. (required)
        :param int project_id: Selected project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_metadatas_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_metadatas_post`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_metadatas_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/metadatas', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_put(self, body, project_id, **kwargs):  # noqa: E501
        """Update properties for a selected project.  # noqa: E501

        This endpoint is aimed to update the properties of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_put(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectReq body: Updates of project. (required)
        :param int project_id: Selected project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_put_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_put_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_put_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Update properties for a selected project.  # noqa: E501

        This endpoint is aimed to update the properties of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_put_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectReq body: Updates of project. (required)
        :param int project_id: Selected project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_put`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_robots_get(self, project_id, **kwargs):  # noqa: E501
        """Get all robot accounts of specified project  # noqa: E501

        Get all robot accounts of specified project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[RobotAccount]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_robots_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_robots_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_robots_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get all robot accounts of specified project  # noqa: E501

        Get all robot accounts of specified project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[RobotAccount]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_robots_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_robots_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/robots', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RobotAccount]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_robots_post(self, body, project_id, **kwargs):  # noqa: E501
        """Create a robot account for project  # noqa: E501

        Create a robot account for project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_post(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RobotAccountCreate body: Request body of creating a robot account. (required)
        :param int project_id: Relevant project ID. (required)
        :return: RobotAccountPostRep
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_robots_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_robots_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_robots_post_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Create a robot account for project  # noqa: E501

        Create a robot account for project  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_post_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RobotAccountCreate body: Request body of creating a robot account. (required)
        :param int project_id: Relevant project ID. (required)
        :return: RobotAccountPostRep
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_robots_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_robots_post`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_robots_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/robots', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RobotAccountPostRep',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_robots_robot_id_delete(self, project_id, robot_id, **kwargs):  # noqa: E501
        """Delete the specified robot account  # noqa: E501

        Delete the specified robot account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_delete(project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_robots_robot_id_delete_with_http_info(project_id, robot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_robots_robot_id_delete_with_http_info(project_id, robot_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_robots_robot_id_delete_with_http_info(self, project_id, robot_id, **kwargs):  # noqa: E501
        """Delete the specified robot account  # noqa: E501

        Delete the specified robot account  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_delete_with_http_info(project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'robot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_robots_robot_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_robots_robot_id_delete`")  # noqa: E501
        # verify the required parameter 'robot_id' is set
        if ('robot_id' not in params or
                params['robot_id'] is None):
            raise ValueError("Missing the required parameter `robot_id` when calling `projects_project_id_robots_robot_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'robot_id' in params:
            path_params['robot_id'] = params['robot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/robots/{robot_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_robots_robot_id_get(self, project_id, robot_id, **kwargs):  # noqa: E501
        """Return the infor of the specified robot account.  # noqa: E501

        Return the infor of the specified robot account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_get(project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: RobotAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_robots_robot_id_get_with_http_info(project_id, robot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_robots_robot_id_get_with_http_info(project_id, robot_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_robots_robot_id_get_with_http_info(self, project_id, robot_id, **kwargs):  # noqa: E501
        """Return the infor of the specified robot account.  # noqa: E501

        Return the infor of the specified robot account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_get_with_http_info(project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: RobotAccount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'robot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_robots_robot_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_robots_robot_id_get`")  # noqa: E501
        # verify the required parameter 'robot_id' is set
        if ('robot_id' not in params or
                params['robot_id'] is None):
            raise ValueError("Missing the required parameter `robot_id` when calling `projects_project_id_robots_robot_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'robot_id' in params:
            path_params['robot_id'] = params['robot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/robots/{robot_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RobotAccount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_robots_robot_id_put(self, body, project_id, robot_id, **kwargs):  # noqa: E501
        """Update status of robot account.  # noqa: E501

        Used to disable/enable a specified robot account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_put(body, project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RobotAccountUpdate body: Request body of enable/disable a robot account. (required)
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_robots_robot_id_put_with_http_info(body, project_id, robot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_robots_robot_id_put_with_http_info(body, project_id, robot_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_robots_robot_id_put_with_http_info(self, body, project_id, robot_id, **kwargs):  # noqa: E501
        """Update status of robot account.  # noqa: E501

        Used to disable/enable a specified robot account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_robots_robot_id_put_with_http_info(body, project_id, robot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RobotAccountUpdate body: Request body of enable/disable a robot account. (required)
        :param int project_id: Relevant project ID. (required)
        :param int robot_id: The ID of robot account. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id', 'robot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_robots_robot_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_robots_robot_id_put`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_robots_robot_id_put`")  # noqa: E501
        # verify the required parameter 'robot_id' is set
        if ('robot_id' not in params or
                params['robot_id'] is None):
            raise ValueError("Missing the required parameter `robot_id` when calling `projects_project_id_robots_robot_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'robot_id' in params:
            path_params['robot_id'] = params['robot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/robots/{robot_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_scanner_candidates_get(self, project_id, **kwargs):  # noqa: E501
        """Get scanner registration candidates for configurating project level scanner  # noqa: E501

        Retrieve the system configured scanner registrations as candidates of setting project level scanner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_scanner_candidates_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project identifier. (required)
        :return: list[ScannerRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_scanner_candidates_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_scanner_candidates_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_scanner_candidates_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get scanner registration candidates for configurating project level scanner  # noqa: E501

        Retrieve the system configured scanner registrations as candidates of setting project level scanner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_scanner_candidates_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project identifier. (required)
        :return: list[ScannerRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_scanner_candidates_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_scanner_candidates_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/scanner/candidates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ScannerRegistration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_scanner_get(self, project_id, **kwargs):  # noqa: E501
        """Get project level scanner  # noqa: E501

        Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_scanner_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project identifier. (required)
        :return: ScannerRegistration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_scanner_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_scanner_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_scanner_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get project level scanner  # noqa: E501

        Get the scanner registration of the specified project. If no scanner registration is configured for the specified project, the system default scanner registration will be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_scanner_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: The project identifier. (required)
        :return: ScannerRegistration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_scanner_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_scanner_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/scanner', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScannerRegistration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_summary_get(self, project_id, **kwargs):  # noqa: E501
        """Get summary of the project.  # noqa: E501

        Get summary of the project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_summary_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID (required)
        :return: ProjectSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_summary_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_summary_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_summary_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get summary of the project.  # noqa: E501

        Get summary of the project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_summary_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID (required)
        :return: ProjectSummary
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_summary_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_summary_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/summary', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProjectSummary',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_jobs_get(self, project_id, policy_id, **kwargs):  # noqa: E501
        """List project webhook jobs  # noqa: E501

        This endpoint returns webhook jobs of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_jobs_get(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The policy ID. (required)
        :return: list[WebhookJob]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_jobs_get_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_jobs_get_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_jobs_get_with_http_info(self, project_id, policy_id, **kwargs):  # noqa: E501
        """List project webhook jobs  # noqa: E501

        This endpoint returns webhook jobs of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_jobs_get_with_http_info(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The policy ID. (required)
        :return: list[WebhookJob]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'policy_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_jobs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_jobs_get`")  # noqa: E501
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `projects_project_id_webhook_jobs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []
        if 'policy_id' in params:
            query_params.append(('policy_id', params['policy_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebhookJob]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_lasttrigger_get(self, project_id, **kwargs):  # noqa: E501
        """Get project webhook policy last trigger info  # noqa: E501

        This endpoint returns last trigger information of project webhook policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_lasttrigger_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[WebhookLastTrigger]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_lasttrigger_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_lasttrigger_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_lasttrigger_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get project webhook policy last trigger info  # noqa: E501

        This endpoint returns last trigger information of project webhook policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_lasttrigger_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[WebhookLastTrigger]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_lasttrigger_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_lasttrigger_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/lasttrigger', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebhookLastTrigger]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_get(self, project_id, **kwargs):  # noqa: E501
        """List project webhook policies.  # noqa: E501

        This endpoint returns webhook policies of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[WebhookPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """List project webhook policies.  # noqa: E501

        This endpoint returns webhook policies of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :return: list[WebhookPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[WebhookPolicy]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_policy_id_delete(self, project_id, policy_id, **kwargs):  # noqa: E501
        """Delete webhook policy of a project  # noqa: E501

        This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_delete(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_policy_id_delete_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_policy_id_delete_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_policy_id_delete_with_http_info(self, project_id, policy_id, **kwargs):  # noqa: E501
        """Delete webhook policy of a project  # noqa: E501

        This endpoint is aimed to delete webhookpolicy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_delete_with_http_info(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'policy_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_policy_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_policy_id_delete`")  # noqa: E501
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `projects_project_id_webhook_policies_policy_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'policy_id' in params:
            path_params['policy_id'] = params['policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies/{policy_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_policy_id_get(self, project_id, policy_id, **kwargs):  # noqa: E501
        """Get project webhook policy  # noqa: E501

        This endpoint returns specified webhook policy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_get(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: WebhookPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_policy_id_get_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_policy_id_get_with_http_info(project_id, policy_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_policy_id_get_with_http_info(self, project_id, policy_id, **kwargs):  # noqa: E501
        """Get project webhook policy  # noqa: E501

        This endpoint returns specified webhook policy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_get_with_http_info(project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: WebhookPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'policy_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_policy_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_policy_id_get`")  # noqa: E501
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `projects_project_id_webhook_policies_policy_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'policy_id' in params:
            path_params['policy_id'] = params['policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies/{policy_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WebhookPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_policy_id_put(self, body, project_id, policy_id, **kwargs):  # noqa: E501
        """Update webhook policy of a project.  # noqa: E501

        This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_put(body, project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: All properties needed except "id", "project_id", "creation_time", "update_time". (required)
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_policy_id_put_with_http_info(body, project_id, policy_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_policy_id_put_with_http_info(body, project_id, policy_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_policy_id_put_with_http_info(self, body, project_id, policy_id, **kwargs):  # noqa: E501
        """Update webhook policy of a project.  # noqa: E501

        This endpoint is aimed to update the webhook policy of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_policy_id_put_with_http_info(body, project_id, policy_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: All properties needed except "id", "project_id", "creation_time", "update_time". (required)
        :param int project_id: Relevant project ID. (required)
        :param int policy_id: The id of webhook policy. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id', 'policy_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_policy_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_webhook_policies_policy_id_put`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_policy_id_put`")  # noqa: E501
        # verify the required parameter 'policy_id' is set
        if ('policy_id' not in params or
                params['policy_id'] is None):
            raise ValueError("Missing the required parameter `policy_id` when calling `projects_project_id_webhook_policies_policy_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501
        if 'policy_id' in params:
            path_params['policy_id'] = params['policy_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies/{policy_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_post(self, body, project_id, **kwargs):  # noqa: E501
        """Create project webhook policy.  # noqa: E501

        This endpoint create a webhook policy if the project does not have one.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_post(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: Properties "targets" and "event_types" needed. (required)
        :param int project_id: Relevant project ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_post_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Create project webhook policy.  # noqa: E501

        This endpoint create a webhook policy if the project does not have one.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_post_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: Properties "targets" and "event_types" needed. (required)
        :param int project_id: Relevant project ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_webhook_policies_post`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def projects_project_id_webhook_policies_test_post(self, body, project_id, **kwargs):  # noqa: E501
        """Test project webhook connection  # noqa: E501

        This endpoint tests webhook connection of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_test_post(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: Only property "targets" needed. (required)
        :param int project_id: Relevant project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.projects_project_id_webhook_policies_test_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.projects_project_id_webhook_policies_test_post_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def projects_project_id_webhook_policies_test_post_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Test project webhook connection  # noqa: E501

        This endpoint tests webhook connection of a project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.projects_project_id_webhook_policies_test_post_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param WebhookPolicy body: Only property "targets" needed. (required)
        :param int project_id: Relevant project ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_project_id_webhook_policies_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `projects_project_id_webhook_policies_test_post`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `projects_project_id_webhook_policies_test_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['project_id'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/projects/{project_id}/webhook/policies/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotas_get(self, **kwargs):  # noqa: E501
        """List quotas  # noqa: E501

        List quotas  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference: The reference type of quota.
        :param str reference_id: The reference id of quota.
        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Quota]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotas_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.quotas_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def quotas_get_with_http_info(self, **kwargs):  # noqa: E501
        """List quotas  # noqa: E501

        List quotas  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str reference: The reference type of quota.
        :param str reference_id: The reference id of quota.
        :param str sort: Sort method, valid values include: 'hard.resource_name', '-hard.resource_name', 'used.resource_name', '-used.resource_name'. Here '-' stands for descending order, resource_name should be the real resource name of the quota. 
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Quota]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['reference', 'reference_id', 'sort', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotas_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'reference' in params:
            query_params.append(('reference', params['reference']))  # noqa: E501
        if 'reference_id' in params:
            query_params.append(('reference_id', params['reference_id']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/quotas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Quota]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotas_id_get(self, id, **kwargs):  # noqa: E501
        """Get the specified quota  # noqa: E501

        Get the specified quota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Quota ID (required)
        :return: Quota
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotas_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotas_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def quotas_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the specified quota  # noqa: E501

        Get the specified quota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Quota ID (required)
        :return: Quota
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotas_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `quotas_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/quotas/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Quota',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotas_id_put(self, body, id, **kwargs):  # noqa: E501
        """Update the specified quota  # noqa: E501

        Update hard limits of the specified quota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_id_put(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuotaUpdateReq body: The new hard limits for the quota (required)
        :param int id: Quota ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotas_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotas_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def quotas_id_put_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update the specified quota  # noqa: E501

        Update hard limits of the specified quota  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_id_put_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param QuotaUpdateReq body: The new hard limits for the quota (required)
        :param int id: Quota ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotas_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `quotas_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `quotas_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/quotas/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_get(self, **kwargs):  # noqa: E501
        """List registries.  # noqa: E501

        This endpoint let user list filtered registries by name, if name is nil, list returns all registries.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Registry's name.
        :return: list[Registry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.registries_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def registries_get_with_http_info(self, **kwargs):  # noqa: E501
        """List registries.  # noqa: E501

        This endpoint let user list filtered registries by name, if name is nil, list returns all registries.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Registry's name.
        :return: list[Registry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Registry]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete specific registry.  # noqa: E501

        This endpoint is for to delete specific registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry's ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def registries_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete specific registry.  # noqa: E501

        This endpoint is for to delete specific registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry's ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `registries_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_id_get(self, id, **kwargs):  # noqa: E501
        """Get registry.  # noqa: E501

        This endpoint is for get specific registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :return: Registry
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def registries_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get registry.  # noqa: E501

        This endpoint is for get specific registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :return: Registry
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `registries_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Registry',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_id_info_get(self, id, **kwargs):  # noqa: E501
        """Get registry info.  # noqa: E501

        Get the info of one specific registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_info_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :return: RegistryInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_id_info_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_id_info_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def registries_id_info_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get registry info.  # noqa: E501

        Get the info of one specific registry.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_info_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :return: RegistryInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_id_info_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `registries_id_info_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/{id}/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistryInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_id_namespace_get(self, id, **kwargs):  # noqa: E501
        """List namespaces of registry  # noqa: E501

        This endpoint let user list namespaces of registry according to query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_namespace_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :param str name: The name of namespace.
        :return: list[Namespace]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_id_namespace_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_id_namespace_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def registries_id_namespace_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """List namespaces of registry  # noqa: E501

        This endpoint let user list namespaces of registry according to query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_namespace_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The registry ID. (required)
        :param str name: The name of namespace.
        :return: list[Namespace]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_id_namespace_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `registries_id_namespace_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/{id}/namespace', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Namespace]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_id_put(self, body, id, **kwargs):  # noqa: E501
        """Update a given registry.  # noqa: E501

        This endpoint is for update a given registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_put(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutRegistry body: Updates registry. (required)
        :param int id: The registry's ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def registries_id_put_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update a given registry.  # noqa: E501

        This endpoint is for update a given registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_id_put_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PutRegistry body: Updates registry. (required)
        :param int id: The registry's ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `registries_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `registries_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_ping_post(self, body, **kwargs):  # noqa: E501
        """Ping status of a registry.  # noqa: E501

        This endpoint checks status of a registry, the registry can be given by ID or URL (together with credential)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_ping_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Registry body: Registry to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_ping_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_ping_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def registries_ping_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Ping status of a registry.  # noqa: E501

        This endpoint checks status of a registry, the registry can be given by ID or URL (together with credential)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_ping_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Registry body: Registry to ping. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `registries_ping_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def registries_post(self, body, **kwargs):  # noqa: E501
        """Create a new registry.  # noqa: E501

        This endpoint is for user to create a new registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Registry body: New created registry. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.registries_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.registries_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def registries_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a new registry.  # noqa: E501

        This endpoint is for user to create a new registry.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.registries_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Registry body: New created registry. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method registries_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `registries_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/registries', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_adapters_get(self, **kwargs):  # noqa: E501
        """List supported adapters.  # noqa: E501

        This endpoint let user list supported adapters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_adapters_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_adapters_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.replication_adapters_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def replication_adapters_get_with_http_info(self, **kwargs):  # noqa: E501
        """List supported adapters.  # noqa: E501

        This endpoint let user list supported adapters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_adapters_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[str]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_adapters_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/adapters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[str]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_get(self, **kwargs):  # noqa: E501
        """List replication executions.  # noqa: E501

        This endpoint let user list replication executions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int policy_id: The policy ID.
        :param str status: The execution status.
        :param str trigger: The trigger mode.
        :param int page: The page.
        :param int page_size: The page size.
        :return: list[ReplicationExecution]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def replication_executions_get_with_http_info(self, **kwargs):  # noqa: E501
        """List replication executions.  # noqa: E501

        This endpoint let user list replication executions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int policy_id: The policy ID.
        :param str status: The execution status.
        :param str trigger: The trigger mode.
        :param int page: The page.
        :param int page_size: The page size.
        :return: list[ReplicationExecution]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['policy_id', 'status', 'trigger', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'policy_id' in params:
            query_params.append(('policy_id', params['policy_id']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'trigger' in params:
            query_params.append(('trigger', params['trigger']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReplicationExecution]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_id_get(self, id, **kwargs):  # noqa: E501
        """Get the execution of the replication.  # noqa: E501

        This endpoint is for user to get one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: ReplicationExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_executions_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the execution of the replication.  # noqa: E501

        This endpoint is for user to get one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: ReplicationExecution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_executions_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReplicationExecution',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_id_put(self, id, **kwargs):  # noqa: E501
        """Stop the execution of the replication.  # noqa: E501

        This endpoint is for user to stop one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_put(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_id_put_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_id_put_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_executions_id_put_with_http_info(self, id, **kwargs):  # noqa: E501
        """Stop the execution of the replication.  # noqa: E501

        This endpoint is for user to stop one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_put_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_executions_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_id_tasks_get(self, id, **kwargs):  # noqa: E501
        """Get the task list of one execution.  # noqa: E501

        This endpoint is for user to get the task list of one execution.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_tasks_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: list[ReplicationTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_id_tasks_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_id_tasks_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_executions_id_tasks_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the task list of one execution.  # noqa: E501

        This endpoint is for user to get the task list of one execution.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_tasks_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :return: list[ReplicationTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_id_tasks_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_executions_id_tasks_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions/{id}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReplicationTask]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_id_tasks_task_id_log_get(self, id, task_id, **kwargs):  # noqa: E501
        """Get the log of one task.  # noqa: E501

        This endpoint is for user to get the log of one task.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_tasks_task_id_log_get(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :param int task_id: The task ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_id_tasks_task_id_log_get_with_http_info(id, task_id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_id_tasks_task_id_log_get_with_http_info(id, task_id, **kwargs)  # noqa: E501
            return data

    def replication_executions_id_tasks_task_id_log_get_with_http_info(self, id, task_id, **kwargs):  # noqa: E501
        """Get the log of one task.  # noqa: E501

        This endpoint is for user to get the log of one task.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_id_tasks_task_id_log_get_with_http_info(id, task_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: The execution ID. (required)
        :param int task_id: The task ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'task_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_id_tasks_task_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_executions_id_tasks_task_id_log_get`")  # noqa: E501
        # verify the required parameter 'task_id' is set
        if ('task_id' not in params or
                params['task_id'] is None):
            raise ValueError("Missing the required parameter `task_id` when calling `replication_executions_id_tasks_task_id_log_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'task_id' in params:
            path_params['task_id'] = params['task_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions/{id}/tasks/{task_id}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_executions_post(self, body, **kwargs):  # noqa: E501
        """Start one execution of the replication.  # noqa: E501

        This endpoint is for user to start one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationExecution body: The execution that needs to be started, only the property "policy_id" is needed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_executions_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_executions_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def replication_executions_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Start one execution of the replication.  # noqa: E501

        This endpoint is for user to start one execution of the replication.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_executions_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationExecution body: The execution that needs to be started, only the property "policy_id" is needed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_executions_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `replication_executions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/executions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_policies_get(self, **kwargs):  # noqa: E501
        """List replication policies  # noqa: E501

        This endpoint let user list replication policies   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The replication policy name.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[ReplicationPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_policies_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.replication_policies_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def replication_policies_get_with_http_info(self, **kwargs):  # noqa: E501
        """List replication policies  # noqa: E501

        This endpoint let user list replication policies   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: The replication policy name.
        :param int page: The page nubmer.
        :param int page_size: The size of per page.
        :return: list[ReplicationPolicy]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_policies_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/policies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ReplicationPolicy]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_policies_id_delete(self, id, **kwargs):  # noqa: E501
        """Delete the replication policy specified by ID.  # noqa: E501

        Delete the replication policy specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_delete(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Replication policy ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_policies_id_delete_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_policies_id_delete_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_policies_id_delete_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete the replication policy specified by ID.  # noqa: E501

        Delete the replication policy specified by ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_delete_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Replication policy ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_policies_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_policies_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/policies/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_policies_id_get(self, id, **kwargs):  # noqa: E501
        """Get replication policy.  # noqa: E501

        This endpoint let user get replication policy by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: policy ID (required)
        :return: ReplicationPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_policies_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_policies_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def replication_policies_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get replication policy.  # noqa: E501

        This endpoint let user get replication policy by specific ID.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: policy ID (required)
        :return: ReplicationPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_policies_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_policies_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/policies/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReplicationPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_policies_id_put(self, body, id, **kwargs):  # noqa: E501
        """Update the replication policy  # noqa: E501

        This endpoint let user update policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_put(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationPolicy body: The replication policy model. (required)
        :param int id: policy ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_policies_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_policies_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def replication_policies_id_put_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update the replication policy  # noqa: E501

        This endpoint let user update policy.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_id_put_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationPolicy body: The replication policy model. (required)
        :param int id: policy ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_policies_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `replication_policies_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `replication_policies_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/policies/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def replication_policies_post(self, body, **kwargs):  # noqa: E501
        """Create a replication policy  # noqa: E501

        This endpoint let user create a replication policy   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationPolicy body: The policy model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.replication_policies_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.replication_policies_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def replication_policies_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a replication policy  # noqa: E501

        This endpoint let user create a replication policy   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.replication_policies_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReplicationPolicy body: The policy model. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method replication_policies_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `replication_policies_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/replication/policies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_get(self, project_id, **kwargs):  # noqa: E501
        """Get repositories accompany with relevant project and repo name.  # noqa: E501

        This endpoint lets user search repositories accompanying with relevant project ID and repo name. Repositories can be sorted by repo name, creation_time, update_time in either ascending or descending order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_get(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param str sort: Sort method, valid values include: 'name', '-name', 'creation_time', '-creation_time', 'update_time', '-update_time'. Here '-' stands for descending order. 
        :param int label_id: The ID of label used to filter the result.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_get_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_get_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def repositories_get_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get repositories accompany with relevant project and repo name.  # noqa: E501

        This endpoint lets user search repositories accompanying with relevant project ID and repo name. Repositories can be sorted by repo name, creation_time, update_time in either ascending or descending order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_get_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: Relevant project ID. (required)
        :param str q: Repo name for filtering results.
        :param str sort: Sort method, valid values include: 'name', '-name', 'creation_time', '-creation_time', 'update_time', '-update_time'. Here '-' stands for descending order. 
        :param int label_id: The ID of label used to filter the result.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page, default is 10, maximum is 100.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'q', 'sort', 'label_id', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `repositories_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'project_id' in params:
            query_params.append(('project_id', params['project_id']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'label_id' in params:
            query_params.append(('label_id', params['label_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_delete(self, repo_name, **kwargs):  # noqa: E501
        """Delete a repository.  # noqa: E501

        This endpoint let user delete a repository with name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_delete(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_delete_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_delete_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Delete a repository.  # noqa: E501

        This endpoint let user delete a repository with name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_delete_with_http_info(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_get(self, repo_name, **kwargs):  # noqa: E501
        """Get labels of a repository.  # noqa: E501

        Get labels of a repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_get(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_labels_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get labels of a repository.  # noqa: E501

        Get labels of a repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_get_with_http_info(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_label_id_delete(self, repo_name, label_id, **kwargs):  # noqa: E501
        """Delete label from the repository.  # noqa: E501

        Delete the label from the repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_label_id_delete(repo_name, label_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_label_id_delete_with_http_info(self, repo_name, label_id, **kwargs):  # noqa: E501
        """Delete label from the repository.  # noqa: E501

        Delete the label from the repository specified by the repo_name.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_label_id_delete_with_http_info(repo_name, label_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'label_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_label_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params or
                params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `repositories_repo_name_labels_label_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'label_id' in params:
            path_params['label_id'] = params['label_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels/{label_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_labels_post(self, body, repo_name, **kwargs):  # noqa: E501
        """Add a label to the repository.  # noqa: E501

        Add a label to the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_post(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: Only the ID property is required. (required)
        :param str repo_name: The name of repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_labels_post_with_http_info(body, repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_labels_post_with_http_info(body, repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_labels_post_with_http_info(self, body, repo_name, **kwargs):  # noqa: E501
        """Add a label to the repository.  # noqa: E501

        Add a label to the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_labels_post_with_http_info(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: Only the ID property is required. (required)
        :param str repo_name: The name of repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `repositories_repo_name_labels_post`")  # noqa: E501
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_put(self, body, repo_name, **kwargs):  # noqa: E501
        """Update description of the repository.  # noqa: E501

        This endpoint is used to update description of the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_put(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryDescription body: The description of the repository. (required)
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_put_with_http_info(body, repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_put_with_http_info(body, repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_put_with_http_info(self, body, repo_name, **kwargs):  # noqa: E501
        """Update description of the repository.  # noqa: E501

        This endpoint is used to update description of the repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_put_with_http_info(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepositoryDescription body: The description of the repository. (required)
        :param str repo_name: The name of repository which will be deleted. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `repositories_repo_name_put`")  # noqa: E501
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_signatures_get(self, repo_name, **kwargs):  # noqa: E501
        """Get signature information of a repository  # noqa: E501

        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_signatures_get(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_signatures_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_signatures_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get signature information of a repository  # noqa: E501

        This endpoint aims to retrieve signature information of a repository, the data is from the nested notary instance of Harbor. If the repository does not have any signature information in notary, this API will return an empty list with response code 200, instead of 404   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_signatures_get_with_http_info(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: repository name. (required)
        :return: list[RepoSignature]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_signatures_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_signatures_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/signatures', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepoSignature]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_get(self, repo_name, **kwargs):  # noqa: E501
        """Get tags of a relevant repository.  # noqa: E501

        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_get(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Relevant repository name. (required)
        :param str label_id: A label ID.
        :param bool detail: Bool value indicating whether return detailed information of the tag, such as vulnerability scan info, if set to false, only tag name is returned.
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_get_with_http_info(repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_get_with_http_info(self, repo_name, **kwargs):  # noqa: E501
        """Get tags of a relevant repository.  # noqa: E501

        This endpoint aims to retrieve tags from a relevant repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_get_with_http_info(repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Relevant repository name. (required)
        :param str label_id: A label ID.
        :param bool detail: Bool value indicating whether return detailed information of the tag, such as vulnerability scan info, if set to false, only tag name is returned.
        :return: list[DetailedTag]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'label_id', 'detail']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []
        if 'label_id' in params:
            query_params.append(('label_id', params['label_id']))  # noqa: E501
        if 'detail' in params:
            query_params.append(('detail', params['detail']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DetailedTag]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_post(self, body, repo_name, **kwargs):  # noqa: E501
        """Retag an image  # noqa: E501

        This endpoint tags an existing image with another tag in this repo, source images can be in different repos or projects.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_post(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetagReq body: Request to give source image and target tag. (required)
        :param str repo_name: Relevant repository name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_post_with_http_info(body, repo_name, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_post_with_http_info(body, repo_name, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_post_with_http_info(self, body, repo_name, **kwargs):  # noqa: E501
        """Retag an image  # noqa: E501

        This endpoint tags an existing image with another tag in this repo, source images can be in different repos or projects.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_post_with_http_info(body, repo_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetagReq body: Request to give source image and target tag. (required)
        :param str repo_name: Relevant repository name. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repo_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `repositories_repo_name_tags_post`")  # noqa: E501
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_delete(self, repo_name, tag, **kwargs):  # noqa: E501
        """Delete a tag in a repository.  # noqa: E501

        This endpoint let user delete tags with repo name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_delete(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_delete_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Delete a tag in a repository.  # noqa: E501

        This endpoint let user delete tags with repo name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_delete_with_http_info(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository which will be deleted. (required)
        :param str tag: Tag of a repository. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_delete`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get the tag of the repository.  # noqa: E501

        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_get(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get the tag of the repository.  # noqa: E501

        This endpoint aims to retrieve the tag of the repository. If deployed with Notary, the signature property of response represents whether the image is singed or not. If the property is null, the image is unsigned.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_get_with_http_info(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Relevant repository name. (required)
        :param str tag: Tag of the repository. (required)
        :return: DetailedTag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DetailedTag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get labels of an image.  # noqa: E501

        Get labels of an image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_get(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get labels of an image.  # noqa: E501

        Get labels of an image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_get_with_http_info(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: list[Label]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Label]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_label_id_delete(self, repo_name, tag, label_id, **kwargs):  # noqa: E501
        """Delete label from the image.  # noqa: E501

        Delete the label from the image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_label_id_delete(repo_name, tag, label_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(self, repo_name, tag, label_id, **kwargs):  # noqa: E501
        """Delete label from the image.  # noqa: E501

        Delete the label from the image specified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_label_id_delete_with_http_info(repo_name, tag, label_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :param int label_id: The ID of label. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'label_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_label_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501
        # verify the required parameter 'label_id' is set
        if ('label_id' not in params or
                params['label_id'] is None):
            raise ValueError("Missing the required parameter `label_id` when calling `repositories_repo_name_tags_tag_labels_label_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501
        if 'label_id' in params:
            path_params['label_id'] = params['label_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels/{label_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_labels_post(self, body, repo_name, tag, **kwargs):  # noqa: E501
        """Add a label to image.  # noqa: E501

        Add a label to the image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_post(body, repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: Only the ID property is required. (required)
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_labels_post_with_http_info(body, repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_labels_post_with_http_info(body, repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_labels_post_with_http_info(self, body, repo_name, tag, **kwargs):  # noqa: E501
        """Add a label to image.  # noqa: E501

        Add a label to the image.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_labels_post_with_http_info(body, repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Label body: Only the ID property is required. (required)
        :param str repo_name: The name of repository. (required)
        :param str tag: The tag of the image. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'repo_name', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_labels_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_labels_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_manifest_get(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get manifests of a relevant repository.  # noqa: E501

        This endpoint aims to retreive manifests from a relevant repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_manifest_get_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Get manifests of a relevant repository.  # noqa: E501

        This endpoint aims to retreive manifests from a relevant repository.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_manifest_get_with_http_info(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str version: The version of manifest, valid value are \"v1\" and \"v2\", default is \"v2\"
        :return: Manifest
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_manifest_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_manifest_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_manifest_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Manifest',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_scan_post(self, repo_name, tag, **kwargs):  # noqa: E501
        """Scan the image.  # noqa: E501

        Trigger a scan targeting the artifact identified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_post(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_scan_post_with_http_info(self, repo_name, tag, **kwargs):  # noqa: E501
        """Scan the image.  # noqa: E501

        Trigger a scan targeting the artifact identified by the repo_name and tag.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_post_with_http_info(repo_name, tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_scan_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_scan_post`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_scan_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/scan', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_repo_name_tags_tag_scan_uuid_log_get(self, repo_name, tag, uuid, **kwargs):  # noqa: E501
        """Get scan log  # noqa: E501

        Get the log text stream for the given artifact and scan action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_uuid_log_get(repo_name, tag, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str uuid: the scan unique identifier (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_repo_name_tags_tag_scan_uuid_log_get_with_http_info(repo_name, tag, uuid, **kwargs)  # noqa: E501
        else:
            (data) = self.repositories_repo_name_tags_tag_scan_uuid_log_get_with_http_info(repo_name, tag, uuid, **kwargs)  # noqa: E501
            return data

    def repositories_repo_name_tags_tag_scan_uuid_log_get_with_http_info(self, repo_name, tag, uuid, **kwargs):  # noqa: E501
        """Get scan log  # noqa: E501

        Get the log text stream for the given artifact and scan action.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_repo_name_tags_tag_scan_uuid_log_get_with_http_info(repo_name, tag, uuid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str repo_name: Repository name (required)
        :param str tag: Tag name (required)
        :param str uuid: the scan unique identifier (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['repo_name', 'tag', 'uuid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_repo_name_tags_tag_scan_uuid_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'repo_name' is set
        if ('repo_name' not in params or
                params['repo_name'] is None):
            raise ValueError("Missing the required parameter `repo_name` when calling `repositories_repo_name_tags_tag_scan_uuid_log_get`")  # noqa: E501
        # verify the required parameter 'tag' is set
        if ('tag' not in params or
                params['tag'] is None):
            raise ValueError("Missing the required parameter `tag` when calling `repositories_repo_name_tags_tag_scan_uuid_log_get`")  # noqa: E501
        # verify the required parameter 'uuid' is set
        if ('uuid' not in params or
                params['uuid'] is None):
            raise ValueError("Missing the required parameter `uuid` when calling `repositories_repo_name_tags_tag_scan_uuid_log_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'repo_name' in params:
            path_params['repo_name'] = params['repo_name']  # noqa: E501
        if 'tag' in params:
            path_params['tag'] = params['tag']  # noqa: E501
        if 'uuid' in params:
            path_params['uuid'] = params['uuid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/{repo_name}/tags/{tag}/scan/{uuid}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def repositories_top_get(self, **kwargs):  # noqa: E501
        """Get public repositories which are accessed most.  # noqa: E501

        This endpoint aims to let users see the most popular public repositories   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_top_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.repositories_top_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.repositories_top_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def repositories_top_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get public repositories which are accessed most.  # noqa: E501

        This endpoint aims to let users see the most popular public repositories   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.repositories_top_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int count: The number of the requested public repositories, default is 10 if not provided.
        :return: list[Repository]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['count']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method repositories_top_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'count' in params:
            query_params.append(('count', params['count']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/repositories/top', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Repository]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_executions_eid_patch(self, body, id, eid, **kwargs):  # noqa: E501
        """Stop a Retention job  # noqa: E501

        Stop a Retention job, only support \"stop\" action now.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_patch(body, id, eid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body6 body: The action, only support "stop" now. (required)
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_executions_eid_patch_with_http_info(body, id, eid, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_executions_eid_patch_with_http_info(body, id, eid, **kwargs)  # noqa: E501
            return data

    def retentions_id_executions_eid_patch_with_http_info(self, body, id, eid, **kwargs):  # noqa: E501
        """Stop a Retention job  # noqa: E501

        Stop a Retention job, only support \"stop\" action now.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_patch_with_http_info(body, id, eid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body6 body: The action, only support "stop" now. (required)
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id', 'eid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_executions_eid_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `retentions_id_executions_eid_patch`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_executions_eid_patch`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `retentions_id_executions_eid_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}/executions/{eid}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_executions_eid_tasks_get(self, id, eid, **kwargs):  # noqa: E501
        """Get Retention job tasks  # noqa: E501

        Get Retention job tasks, each repository as a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_tasks_get(id, eid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :return: list[RetentionExecutionTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_executions_eid_tasks_get_with_http_info(id, eid, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_executions_eid_tasks_get_with_http_info(id, eid, **kwargs)  # noqa: E501
            return data

    def retentions_id_executions_eid_tasks_get_with_http_info(self, id, eid, **kwargs):  # noqa: E501
        """Get Retention job tasks  # noqa: E501

        Get Retention job tasks, each repository as a task.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_tasks_get_with_http_info(id, eid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :return: list[RetentionExecutionTask]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'eid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_executions_eid_tasks_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_executions_eid_tasks_get`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `retentions_id_executions_eid_tasks_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}/executions/{eid}/tasks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RetentionExecutionTask]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_executions_eid_tasks_tid_get(self, id, eid, tid, **kwargs):  # noqa: E501
        """Get Retention job task log  # noqa: E501

        Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_tasks_tid_get(id, eid, tid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :param int tid: Retention execution ID. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_executions_eid_tasks_tid_get_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_executions_eid_tasks_tid_get_with_http_info(id, eid, tid, **kwargs)  # noqa: E501
            return data

    def retentions_id_executions_eid_tasks_tid_get_with_http_info(self, id, eid, tid, **kwargs):  # noqa: E501
        """Get Retention job task log  # noqa: E501

        Get Retention job task log, tags ratain or deletion detail will be shown in a table.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_eid_tasks_tid_get_with_http_info(id, eid, tid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :param int eid: Retention execution ID. (required)
        :param int tid: Retention execution ID. (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'eid', 'tid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_executions_eid_tasks_tid_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_executions_eid_tasks_tid_get`")  # noqa: E501
        # verify the required parameter 'eid' is set
        if ('eid' not in params or
                params['eid'] is None):
            raise ValueError("Missing the required parameter `eid` when calling `retentions_id_executions_eid_tasks_tid_get`")  # noqa: E501
        # verify the required parameter 'tid' is set
        if ('tid' not in params or
                params['tid'] is None):
            raise ValueError("Missing the required parameter `tid` when calling `retentions_id_executions_eid_tasks_tid_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'eid' in params:
            path_params['eid'] = params['eid']  # noqa: E501
        if 'tid' in params:
            path_params['tid'] = params['tid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}/executions/{eid}/tasks/{tid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_executions_get(self, id, **kwargs):  # noqa: E501
        """Get a Retention job  # noqa: E501

        Get a Retention job, job status may be delayed before job service schedule it up.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :return: list[RetentionExecution]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_executions_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_executions_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retentions_id_executions_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get a Retention job  # noqa: E501

        Get a Retention job, job status may be delayed before job service schedule it up.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :return: list[RetentionExecution]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_executions_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_executions_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}/executions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RetentionExecution]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_executions_post(self, body, id, **kwargs):  # noqa: E501
        """Trigger a Retention job  # noqa: E501

        Trigger a Retention job, if dry_run is True, nothing would be deleted actually.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_post(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body5 body: (required)
        :param int id: Retention ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_executions_post_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_executions_post_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def retentions_id_executions_post_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Trigger a Retention job  # noqa: E501

        Trigger a Retention job, if dry_run is True, nothing would be deleted actually.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_executions_post_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body5 body: (required)
        :param int id: Retention ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_executions_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `retentions_id_executions_post`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_executions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}/executions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_get(self, id, **kwargs):  # noqa: E501
        """Get Retention Policy  # noqa: E501

        Get Retention Policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :return: RetentionPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retentions_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get Retention Policy  # noqa: E501

        Get Retention Policy.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Retention ID. (required)
        :return: RetentionPolicy
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RetentionPolicy',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_id_put(self, body, id, **kwargs):  # noqa: E501
        """Update Retention Policy  # noqa: E501

        Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_put(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetentionPolicy body: (required)
        :param int id: Retention ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_id_put_with_http_info(body, id, **kwargs)  # noqa: E501
            return data

    def retentions_id_put_with_http_info(self, body, id, **kwargs):  # noqa: E501
        """Update Retention Policy  # noqa: E501

        Update Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when retention policy has already binded to project.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_id_put_with_http_info(body, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetentionPolicy body: (required)
        :param int id: Retention ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `retentions_id_put`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retentions_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_metadatas_get(self, **kwargs):  # noqa: E501
        """Get Retention Metadatas  # noqa: E501

        Get Retention Metadatas.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_metadatas_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RetentionMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_metadatas_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.retentions_metadatas_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def retentions_metadatas_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get Retention Metadatas  # noqa: E501

        Get Retention Metadatas.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_metadatas_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: RetentionMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_metadatas_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions/metadatas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RetentionMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retentions_post(self, body, **kwargs):  # noqa: E501
        """Create Retention Policy  # noqa: E501

        Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetentionPolicy body: Create Retention Policy successfully. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retentions_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.retentions_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def retentions_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Retention Policy  # noqa: E501

        Create Retention Policy, you can reference metadatas API for the policy model. You can check project metadatas to find whether a retention policy is already binded. This method should only be called when no retention policy binded to project yet.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retentions_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RetentionPolicy body: Create Retention Policy successfully. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retentions_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `retentions_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/retentions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scanners_get(self, **kwargs):  # noqa: E501
        """List scanner registrations  # noqa: E501

        Returns a list of currently configured scanner registrations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ScannerRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scanners_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.scanners_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def scanners_get_with_http_info(self, **kwargs):  # noqa: E501
        """List scanner registrations  # noqa: E501

        Returns a list of currently configured scanner registrations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[ScannerRegistration]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scanners_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scanners', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ScannerRegistration]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scanners_ping_post(self, body, **kwargs):  # noqa: E501
        """Tests scanner registration settings  # noqa: E501

        Pings scanner adapter to test endpoint URL and authorization settings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_ping_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScannerRegistrationSettings body: A scanner registration settings to be tested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scanners_ping_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.scanners_ping_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def scanners_ping_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Tests scanner registration settings  # noqa: E501

        Pings scanner adapter to test endpoint URL and authorization settings.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_ping_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScannerRegistrationSettings body: A scanner registration settings to be tested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scanners_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `scanners_ping_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scanners/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scanners_registration_id_get(self, registration_id, **kwargs):  # noqa: E501
        """Get a scanner registration details  # noqa: E501

        Retruns the details of the specified scanner registration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_registration_id_get(registration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registration_id: The scanner registration identifer. (required)
        :return: ScannerRegistration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scanners_registration_id_get_with_http_info(registration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.scanners_registration_id_get_with_http_info(registration_id, **kwargs)  # noqa: E501
            return data

    def scanners_registration_id_get_with_http_info(self, registration_id, **kwargs):  # noqa: E501
        """Get a scanner registration details  # noqa: E501

        Retruns the details of the specified scanner registration.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_registration_id_get_with_http_info(registration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registration_id: The scanner registration identifer. (required)
        :return: ScannerRegistration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scanners_registration_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registration_id' is set
        if ('registration_id' not in params or
                params['registration_id'] is None):
            raise ValueError("Missing the required parameter `registration_id` when calling `scanners_registration_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registration_id' in params:
            path_params['registration_id'] = params['registration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scanners/{registration_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScannerRegistration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scanners_registration_id_metadata_get(self, registration_id, **kwargs):  # noqa: E501
        """Get the metadata of the specified scanner registration  # noqa: E501

        Get the metadata of the specified scanner registration, including the capabilities and customzied properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_registration_id_metadata_get(registration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registration_id: The scanner registration identifier. (required)
        :return: ScannerAdapterMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scanners_registration_id_metadata_get_with_http_info(registration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.scanners_registration_id_metadata_get_with_http_info(registration_id, **kwargs)  # noqa: E501
            return data

    def scanners_registration_id_metadata_get_with_http_info(self, registration_id, **kwargs):  # noqa: E501
        """Get the metadata of the specified scanner registration  # noqa: E501

        Get the metadata of the specified scanner registration, including the capabilities and customzied properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scanners_registration_id_metadata_get_with_http_info(registration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str registration_id: The scanner registration identifier. (required)
        :return: ScannerAdapterMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['registration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scanners_registration_id_metadata_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'registration_id' is set
        if ('registration_id' not in params or
                params['registration_id'] is None):
            raise ValueError("Missing the required parameter `registration_id` when calling `scanners_registration_id_metadata_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'registration_id' in params:
            path_params['registration_id'] = params['registration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scanners/{registration_id}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ScannerAdapterMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scans_all_metrics_get(self, **kwargs):  # noqa: E501
        """Get the metrics of the latest scan all process  # noqa: E501

        Get the metrics of the latest scan all process  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scans_all_metrics_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Stats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scans_all_metrics_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.scans_all_metrics_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def scans_all_metrics_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the metrics of the latest scan all process  # noqa: E501

        Get the metrics of the latest scan all process  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scans_all_metrics_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Stats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scans_all_metrics_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scans/all/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Stats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scans_schedule_metrics_get(self, **kwargs):  # noqa: E501
        """Get the metrics of the latest scheduled scan all process  # noqa: E501

        Get the metrics of the latest scheduled scan all process  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scans_schedule_metrics_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Stats
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scans_schedule_metrics_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.scans_schedule_metrics_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def scans_schedule_metrics_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the metrics of the latest scheduled scan all process  # noqa: E501

        Get the metrics of the latest scheduled scan all process  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scans_schedule_metrics_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: Stats
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scans_schedule_metrics_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/scans/schedule/metrics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Stats',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_get(self, q, **kwargs):  # noqa: E501
        """Search for projects, repositories and helm charts  # noqa: E501

        The Search endpoint returns information about the projects ,repositories  and helm charts offered at public status or related to the current logged in user. The response includes the project, repository list and charts in a proper display order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_get(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_get_with_http_info(q, **kwargs)  # noqa: E501
        else:
            (data) = self.search_get_with_http_info(q, **kwargs)  # noqa: E501
            return data

    def search_get_with_http_info(self, q, **kwargs):  # noqa: E501
        """Search for projects, repositories and helm charts  # noqa: E501

        The Search endpoint returns information about the projects ,repositories  and helm charts offered at public status or related to the current logged in user. The response includes the project, repository list and charts in a proper display order.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_get_with_http_info(q, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str q: Search parameter for project and repository name. (required)
        :return: list[Search]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'q' is set
        if ('q' not in params or
                params['q'] is None):
            raise ValueError("Missing the required parameter `q` when calling `search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Search]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def statistics_get(self, **kwargs):  # noqa: E501
        """Get projects number and repositories number relevant to the user  # noqa: E501

        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statistics_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.statistics_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.statistics_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def statistics_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get projects number and repositories number relevant to the user  # noqa: E501

        This endpoint is aimed to statistic all of the projects number and repositories number relevant to the logined user, also the public projects number and repositories number. If the user is admin, he can also get total projects number and total repositories number.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.statistics_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: StatisticMap
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method statistics_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/statistics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StatisticMap',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_cve_whitelist_get(self, **kwargs):  # noqa: E501
        """Get the system level whitelist of CVE.  # noqa: E501

        Get the system level whitelist of CVE.  This API can be called by all authenticated users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cve_whitelist_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CVEWhitelist
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_cve_whitelist_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_cve_whitelist_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_cve_whitelist_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get the system level whitelist of CVE.  # noqa: E501

        Get the system level whitelist of CVE.  This API can be called by all authenticated users.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cve_whitelist_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CVEWhitelist
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_cve_whitelist_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/CVEWhitelist', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CVEWhitelist',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_cve_whitelist_put(self, **kwargs):  # noqa: E501
        """Update the system level whitelist of CVE.  # noqa: E501

        This API overwrites the system level whitelist of CVE with the list in request body.  Only system Admin has permission to call this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cve_whitelist_put(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CVEWhitelist body: The whitelist with new content
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_cve_whitelist_put_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_cve_whitelist_put_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_cve_whitelist_put_with_http_info(self, **kwargs):  # noqa: E501
        """Update the system level whitelist of CVE.  # noqa: E501

        This API overwrites the system level whitelist of CVE with the list in request body.  Only system Admin has permission to call this API.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_cve_whitelist_put_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CVEWhitelist body: The whitelist with new content
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_cve_whitelist_put" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/CVEWhitelist', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_get(self, **kwargs):  # noqa: E501
        """Get gc results.  # noqa: E501

        This endpoint let user get latest ten gc results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GCResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_gc_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get gc results.  # noqa: E501

        This endpoint let user get latest ten gc results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[GCResult]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[GCResult]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_id_get(self, id, **kwargs):  # noqa: E501
        """Get gc status.  # noqa: E501

        This endpoint let user get gc status filtered by specific ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Relevant job ID (required)
        :return: GCResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def system_gc_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get gc status.  # noqa: E501

        This endpoint let user get gc status filtered by specific ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Relevant job ID (required)
        :return: GCResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `system_gc_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GCResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_id_log_get(self, id, **kwargs):  # noqa: E501
        """Get gc job log.  # noqa: E501

        This endpoint let user get gc job logs filtered by specific ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_id_log_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Relevant job ID (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_id_log_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def system_gc_id_log_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get gc job log.  # noqa: E501

        This endpoint let user get gc job logs filtered by specific ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_id_log_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: Relevant job ID (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_id_log_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `system_gc_id_log_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc/{id}/log', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_schedule_get(self, **kwargs):  # noqa: E501
        """Get gc's schedule.  # noqa: E501

        This endpoint is for get schedule of gc job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminJobSchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_schedule_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_schedule_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_gc_schedule_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get gc's schedule.  # noqa: E501

        This endpoint is for get schedule of gc job.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminJobSchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_schedule_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc/schedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminJobSchedule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_schedule_post(self, body, **kwargs):  # noqa: E501
        """Create a gc schedule.  # noqa: E501

        This endpoint is for update gc schedule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates of gc's schedule. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_schedule_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_schedule_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def system_gc_schedule_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a gc schedule.  # noqa: E501

        This endpoint is for update gc schedule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates of gc's schedule. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_schedule_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_gc_schedule_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc/schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_gc_schedule_put(self, body, **kwargs):  # noqa: E501
        """Update gc's schedule.  # noqa: E501

        This endpoint is for update gc schedule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_put(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates of gc's schedule. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_gc_schedule_put_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.system_gc_schedule_put_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def system_gc_schedule_put_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update gc's schedule.  # noqa: E501

        This endpoint is for update gc schedule.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_gc_schedule_put_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates of gc's schedule. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_gc_schedule_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_gc_schedule_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/gc/schedule', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_oidc_ping_post(self, body, **kwargs):  # noqa: E501
        """Test the OIDC endpoint.  # noqa: E501

        Test the OIDC endpoint, the setting of the endpoint is provided in the request.  This API can only be called by system admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_oidc_ping_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body4 body: Request body for OIDC endpoint to be tested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_oidc_ping_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.system_oidc_ping_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def system_oidc_ping_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Test the OIDC endpoint.  # noqa: E501

        Test the OIDC endpoint, the setting of the endpoint is provided in the request.  This API can only be called by system admin.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_oidc_ping_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body4 body: Request body for OIDC endpoint to be tested. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_oidc_ping_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_oidc_ping_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/oidc/ping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_scan_all_schedule_get(self, **kwargs):  # noqa: E501
        """Get scan_all's schedule.  # noqa: E501

        This endpoint is for getting a schedule for the scan all job, which scans all of images in Harbor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminJobSchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_scan_all_schedule_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.system_scan_all_schedule_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def system_scan_all_schedule_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get scan_all's schedule.  # noqa: E501

        This endpoint is for getting a schedule for the scan all job, which scans all of images in Harbor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: AdminJobSchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_scan_all_schedule_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/scanAll/schedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AdminJobSchedule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_scan_all_schedule_post(self, body, **kwargs):  # noqa: E501
        """Create a schedule or a manual trigger for the scan all job.  # noqa: E501

        This endpoint is for creating a schedule or a manual trigger for the scan all job, which scans all of images in Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Create a schedule or a manual trigger for the scan all job. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_scan_all_schedule_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.system_scan_all_schedule_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def system_scan_all_schedule_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a schedule or a manual trigger for the scan all job.  # noqa: E501

        This endpoint is for creating a schedule or a manual trigger for the scan all job, which scans all of images in Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Create a schedule or a manual trigger for the scan all job. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_scan_all_schedule_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_scan_all_schedule_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/scanAll/schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def system_scan_all_schedule_put(self, body, **kwargs):  # noqa: E501
        """Update scan all's schedule.  # noqa: E501

        This endpoint is for updating the schedule of scan all job, which scans all of images in Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_put(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.system_scan_all_schedule_put_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.system_scan_all_schedule_put_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def system_scan_all_schedule_put_with_http_info(self, body, **kwargs):  # noqa: E501
        """Update scan all's schedule.  # noqa: E501

        This endpoint is for updating the schedule of scan all job, which scans all of images in Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.system_scan_all_schedule_put_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AdminJobSchedule body: Updates the schedule of scan all job, which scans all of images in Harbor. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method system_scan_all_schedule_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `system_scan_all_schedule_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/system/scanAll/schedule', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_get(self, **kwargs):  # noqa: E501
        """Get general system info  # noqa: E501

        This API is for retrieving general system info, this can be called by anonymous request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GeneralInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.systeminfo_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get general system info  # noqa: E501

        This API is for retrieving general system info, this can be called by anonymous request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: GeneralInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GeneralInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_getcert_get(self, **kwargs):  # noqa: E501
        """Get default root certificate.  # noqa: E501

        This endpoint is for downloading a default root certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_getcert_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.systeminfo_getcert_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_getcert_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_getcert_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get default root certificate.  # noqa: E501

        This endpoint is for downloading a default root certificate.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_getcert_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_getcert_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo/getcert', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def systeminfo_volumes_get(self, **kwargs):  # noqa: E501
        """Get system volume info (total/free size).  # noqa: E501

        This endpoint is for retrieving system volume info that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_volumes_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.systeminfo_volumes_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.systeminfo_volumes_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def systeminfo_volumes_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get system volume info (total/free size).  # noqa: E501

        This endpoint is for retrieving system volume info that only provides for admin user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.systeminfo_volumes_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: SystemInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method systeminfo_volumes_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/systeminfo/volumes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SystemInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_get(self, **kwargs):  # noqa: E501
        """Get all user groups information  # noqa: E501

        Get all user groups information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.usergroups_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def usergroups_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get all user groups information  # noqa: E501

        Get all user groups information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[UserGroup]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserGroup]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_delete(self, group_id, **kwargs):  # noqa: E501
        """Delete user group  # noqa: E501

        Delete user group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_delete(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.usergroups_group_id_delete_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_delete_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_delete_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Delete user group  # noqa: E501

        Delete user group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_delete_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_get(self, group_id, **kwargs):  # noqa: E501
        """Get user group information  # noqa: E501

        Get user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_get(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: Group ID (required)
        :return: UserGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.usergroups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_get_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_get_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Get user group information  # noqa: E501

        Get user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_get_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: Group ID (required)
        :return: UserGroup
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserGroup',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_group_id_put(self, group_id, **kwargs):  # noqa: E501
        """Update group information  # noqa: E501

        Update user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_put(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: Group ID (required)
        :param UserGroup body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.usergroups_group_id_put_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_group_id_put_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def usergroups_group_id_put_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """Update group information  # noqa: E501

        Update user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_group_id_put_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int group_id: Group ID (required)
        :param UserGroup body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_group_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `usergroups_group_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups/{group_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def usergroups_post(self, **kwargs):  # noqa: E501
        """Create user group  # noqa: E501

        Create user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroup body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.usergroups_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.usergroups_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def usergroups_post_with_http_info(self, **kwargs):  # noqa: E501
        """Create user group  # noqa: E501

        Create user group information  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.usergroups_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserGroup body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method usergroups_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/usergroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_current_get(self, **kwargs):  # noqa: E501
        """Get current user info.  # noqa: E501

        This endpoint is to get the current user information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_current_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_current_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_current_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_current_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get current user info.  # noqa: E501

        This endpoint is to get the current user information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_current_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_current_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_current_permissions_get(self, **kwargs):  # noqa: E501
        """Get current user permissions.  # noqa: E501

        This endpoint is to get the current user permissions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_current_permissions_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: Get permissions of the scope
        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
        :return: list[Permission]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_current_permissions_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_current_permissions_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_current_permissions_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get current user permissions.  # noqa: E501

        This endpoint is to get the current user permissions.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_current_permissions_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str scope: Get permissions of the scope
        :param bool relative: If true, the resources in the response are relative to the scope, eg for resource '/project/1/repository' if relative is 'true' then the resource in response will be 'repository'. 
        :return: list[Permission]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['scope', 'relative']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_current_permissions_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
        if 'relative' in params:
            query_params.append(('relative', params['relative']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/current/permissions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Permission]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_get(self, **kwargs):  # noqa: E501
        """Get registered users of Harbor.  # noqa: E501

        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get registered users of Harbor.  # noqa: E501

        This endpoint is for user to search registered users, support for filtering results with username.Notice, by now this operation is only for administrator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username for filtering results.
        :param str email: Email for filtering results.
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'email', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_post(self, body, **kwargs):  # noqa: E501
        """Creates a new user account.  # noqa: E501

        This endpoint is to create a user if the user does not already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param User body: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.users_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def users_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Creates a new user account.  # noqa: E501

        This endpoint is to create a user if the user does not already exist.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param User body: New created user. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_search_get(self, username, **kwargs):  # noqa: E501
        """Search users by username  # noqa: E501

        This endpoint is to search the users by username.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_search_get(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username for filtering results. (required)
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page.
        :return: list[UserSearch]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_search_get_with_http_info(username, **kwargs)  # noqa: E501
        else:
            (data) = self.users_search_get_with_http_info(username, **kwargs)  # noqa: E501
            return data

    def users_search_get_with_http_info(self, username, **kwargs):  # noqa: E501
        """Search users by username  # noqa: E501

        This endpoint is to search the users by username.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_search_get_with_http_info(username, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str username: Username for filtering results. (required)
        :param int page: The page number, default is 1.
        :param int page_size: The size of per page.
        :return: list[UserSearch]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['username', 'page', 'page_size']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_search_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'username' is set
        if ('username' not in params or
                params['username'] is None):
            raise ValueError("Missing the required parameter `username` when calling `users_search_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'username' in params:
            query_params.append(('username', params['username']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('page_size', params['page_size']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserSearch]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_cli_secret_put(self, body, user_id, **kwargs):  # noqa: E501
        """Set CLI secret for a user.  # noqa: E501

        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_cli_secret_put(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body body: JSON object that includes the new secret (required)
        :param int user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_cli_secret_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_cli_secret_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_cli_secret_put_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Set CLI secret for a user.  # noqa: E501

        This endpoint let user generate a new CLI secret for himself.  This API only works when auth mode is set to 'OIDC'. Once this API returns with successful status, the old secret will be invalid, as there will be only one CLI secret for a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_cli_secret_put_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body body: JSON object that includes the new secret (required)
        :param int user_id: User ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_cli_secret_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_user_id_cli_secret_put`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_cli_secret_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/cli_secret', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_delete(self, user_id, **kwargs):  # noqa: E501
        """Mark a registered user as be removed.  # noqa: E501

        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_delete(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_delete_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_delete_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Mark a registered user as be removed.  # noqa: E501

        This endpoint let administrator of Harbor mark a registered user as be removed.It actually won't be deleted from DB.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_delete_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: User ID for marking as to be removed. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_get(self, user_id, **kwargs):  # noqa: E501
        """Get a user's profile.  # noqa: E501

        Get user's profile with user id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_get(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: Registered user ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_get_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_get_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a user's profile.  # noqa: E501

        Get user's profile with user id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_get_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id: Registered user ID (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_password_put(self, body, user_id, **kwargs):  # noqa: E501
        """Change the password on a user that already exists.  # noqa: E501

        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_password_put(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Password body: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
        :param int user_id: Registered user ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_password_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_password_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_password_put_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Change the password on a user that already exists.  # noqa: E501

        This endpoint is for user to update password. Users with the admin role can change any user's password. Guest users can change only their own password.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_password_put_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Password body: Password to be updated, the attribute 'old_password' is optional when the API is called by the system administrator. (required)
        :param int user_id: Registered user ID. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_password_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_user_id_password_put`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_password_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/password', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_put(self, body, user_id, **kwargs):  # noqa: E501
        """Update a registered user to change his profile.  # noqa: E501

        This endpoint let a registered user change his profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_put(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserProfile body: Only email, realname and comment can be modified. (required)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_put_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Update a registered user to change his profile.  # noqa: E501

        This endpoint let a registered user change his profile.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_put_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UserProfile body: Only email, realname and comment can be modified. (required)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_user_id_put`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users_user_id_sysadmin_put(self, body, user_id, **kwargs):  # noqa: E501
        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501

        This endpoint let a registered user change to be an administrator of Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_sysadmin_put(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HasAdminRole body: Toggle a user to admin or not. (required)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_user_id_sysadmin_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.users_user_id_sysadmin_put_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def users_user_id_sysadmin_put_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """Update a registered user to change to be an administrator of Harbor.  # noqa: E501

        This endpoint let a registered user change to be an administrator of Harbor.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_user_id_sysadmin_put_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param HasAdminRole body: Toggle a user to admin or not. (required)
        :param int user_id: Registered user ID (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users_user_id_sysadmin_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `users_user_id_sysadmin_put`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `users_user_id_sysadmin_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basicAuth']  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/sysadmin', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
